
#Область ОбработчикиСобытийФормы

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	Если Параметры.Свойство("АвтоТест") Тогда // Возврат при получении формы для анализа.
		Возврат;
	КонецЕсли; 
		
	
	//TODO: подумать о блокировке варианта сетки при открытии и выборе
	
	ШагСлота 				= "Полчаса"; 
	Объект.Кэш				= ИнициализироватьКэш();
	Интервал.ДатаНачала 	= НачалоНедели(ТекущаяДатаСеанса());
	Интервал.ДатаОкончания 	= КонецНедели(ТекущаяДатаСеанса());
	
	СтрокаЗаголовка = Новый ФорматированнаяСтрока(
		СтрШаблон("%1 неделя", НеделяГода(Интервал.ДатаНачала)),
			Новый Шрифт(,18,Истина),
			WebЦвета.СинийСоСтальнымОттенком);
			
	Элементы.ДекорацияОписаниеНедели.Заголовок = СтрокаЗаголовка;
													
	ИнициализироватьПланировщик();	
	ЗаполнитьДаннымиВариантаСетки();
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Элементы,
		Элементы.ГруппаРедактированиеЭлемента.Имя,
		"Видимость",
		Ложь);

КонецПроцедуры

&НаКлиенте
Процедура ПередЗакрытием(Отказ,СтандартнаяОбработка)
	
	Если Модифицированность Тогда 
		
		ТекстПредупреждения = НСтр("ru='Данные были изменены, внесенные изменения будут отменены.
                                         |Отменить и закрыть?'
                                         |;uk='Дані були змінені, внесені зміни будуть скасовані.
                                         |Скасувати й закрити?'");
		
		ОбщегоНазначенияКлиент.ПоказатьПодтверждениеЗакрытияПроизвольнойФормы(
			ЭтотОбъект,
			Отказ,
			ТекстПредупреждения,
			"ДействиеВыбрано");
		
	КонецЕсли;
	
	
КонецПроцедуры

&НаКлиенте
Процедура ЗаписатьИЗакрытьЗавершение(Результат = Неопределено, ДополнительныеПараметры = Неопределено) Экспорт

	Модифицированность = Ложь;
	Закрыть();
	
КонецПроцедуры

&НаКлиенте
Процедура БыстроеРедактированиеПодсказкаПриИзменении(Элемент)	
	
	Если АвтоматическиСохранятьПриИзменении Тогда
		БыстроеРедактированиеПрименить(Неопределено);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура БыстроеРедактированиеНачалоПриИзменении(Элемент)
	
	Если АвтоматическиСохранятьПриИзменении Тогда
		БыстроеРедактированиеПрименить(Неопределено);
	КонецЕсли;
	
	//TODO: проверить чтобы дата окончания не была меньше даты начала
	
КонецПроцедуры

&НаКлиенте
Процедура БыстроеРедактированиеКонецПриИзменении(Элемент)
	
	Если АвтоматическиСохранятьПриИзменении Тогда
		БыстроеРедактированиеПрименить(Неопределено);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура БыстроеРедактированиеТипПередачиПриИзменении(Элемент)
	
	Если АвтоматическиСохранятьПриИзменении Тогда
		БыстроеРедактированиеПрименить(Неопределено);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовШапкиФормы

&НаКлиенте
Процедура ИнтервалПриИзменении(Элемент)
	
	ИнициализироватьПланировщик();
	ЗаполнитьДаннымиВариантаСетки();
	
КонецПроцедуры

&НаКлиенте
Процедура ВариантСеткиПриИзменении(Элемент)
	
	Планировщик.Элементы.Очистить();
	ЗаполнитьДаннымиВариантаСетки();
	
КонецПроцедуры

&НаКлиенте
Процедура ВысотаСтрокиПриИзменении(Элемент)
	
	Планировщик.МинимальнаяВысотаСтроки = ВысотаСтроки;
	
КонецПроцедуры

#КонецОбласти

#Область СобытияПланировщика

&НаКлиенте
Процедура ПланировщикПриСменеТекущегоПериодаОтображения(Элемент, ТекущиеПериодыОтображения, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	
	
КонецПроцедуры

&НаКлиенте
Процедура ПланировщикВыбор(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	
	ЗначениеЭлемента = Элемент.ВыделенныеЭлементы[0].Значение;
	
	Если ЗначениеЗаполнено(ЗначениеЭлемента) 
		И ТипЗнч(ЗначениеЭлемента) = Тип("ДокументСсылка.слм_ТаймСлот") Тогда
		
		ВызватьИсключение НСтр("ru = 'Ой, что-то пошло не так. Обратитесь к разработчику'");  
		
		ДополнительныеПараметры = Новый Структура;
		ДополнительныеПараметры.Вставить("Значение",ЗначениеЭлемента);		
		Обработчик = Новый ОписаниеОповещения("ПланировщикВыборЗавершение",ЭтотОбъект,ДополнительныеПараметры);
		
		БлокироватьДляИзменения = Новый Структура("ВариантСетки");		
		ПараметрыФормы = Новый Структура("Ключ,БлокироватьДляИзменения",ЗначениеЭлемента,БлокироватьДляИзменения);
		
		//ОткрытьФорму("Документ.слм_ТаймСлот.Форма.,
		//		ПараметрыФормы,,,,,Обработчик,РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс);
		
	Иначе
		
		//TODO: возможно, открывать "легкую" форму редактирования, может поднимать что то из кэша
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура - Планировщик выбор завершение
//
// Параметры:
//  РезультатЗакрытия		 - 	 - 
//  ДополнительныеПараметры	 - 	 - 
//
&НаКлиенте
Процедура ПланировщикВыборЗавершение(РезультатЗакрытия, ДополнительныеПараметры) Экспорт 
	Перем Значение;
	
	Если ДополнительныеПараметры.Свойство("Значение",Значение) Тогда
		
		ОбновитьЭлементНаСервере(Значение);	
		
	КонецЕсли; 	
	
КонецПроцедуры

&НаКлиенте
Процедура ПланировщикПередУдалением(Элемент, Отказ)
	
	Для каждого УдаленныйЭлемент Из Элемент.ВыделенныеЭлементы Цикл
		
		ПараметрыОтбора = Новый Структура("Значение", УдаленныйЭлемент.Значение);
		НайденныеЭлементы = КэшЭлементовПланировщика.НайтиСтроки(ПараметрыОтбора);
		
		Если НайденныеЭлементы.Количество() = 0 Тогда
			
			ВызватьИсключение ТекстИсключения();		
			
		Иначе
			
			ЗаполнитьЗначенияСвойств(НайденныеЭлементы[0], УдаленныйЭлемент.Выгрузить());
			НайденныеЭлементы[0].Удаленный = Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

&НаКлиенте
Процедура ПланировщикПередНачаломБыстрогоРедактирования(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	Элемент = Элемент.ВыделенныеЭлементы[0];
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(ЭтотОбъект.Элементы,Элементы.ГруппаРедактированиеЭлемента.Имя,"Видимость",Истина);
	    	
	БыстроеРедактированиеНачало 	= Элемент.Начало;
	БыстроеРедактированиеКонец		= Элемент.Конец;
	БыстроеРедактированиеПодсказка 	= Элемент.Подсказка;
	НадписьШаблон = СтрШаблон("%1-%2",Формат(БыстроеРедактированиеНачало,"ДФ=ЧЧ:мм:сс"),Формат(БыстроеРедактированиеКонец,"ДФ=ЧЧ:мм:сс"));
	Элементы.БыстроеРедактированиеНадпись.Заголовок	= Новый ФорматированнаяСтрока(НадписьШаблон,,WebЦвета.НейтральноСиний );
	БыстроеРедактированиеЗначение 	= Элемент.Значение;								
	
КонецПроцедуры

&НаКлиенте
Процедура ПланировщикПриОкончанииРедактирования(Элемент, НовыйЭлемент, ОтменаРедактирования)

	Шаг = ОписаниеШаговСлота().Получить(НРег(ШагСлота));	
	
	Если НовыйЭлемент Тогда
		
		Для каждого ВыделенныйЭлемент Из Элемент.ВыделенныеЭлементы Цикл
			
			//NOTE: проверка на пересечение
			Для каждого ЭлементПланировщика Из Планировщик.Элементы Цикл				
				Если ЭлементПланировщика.Значение <> ВыделенныйЭлемент.Значение // проверка на самого себя
					И ИнтервалыПересекаются(ВыделенныйЭлемент.Начало, ВыделенныйЭлемент.Конец, ЭлементПланировщика.Начало,ЭлементПланировщика.Конец) Тогда //есть пересечение
					ОтменаРедактирования = Истина;
				КонецЕсли;				
			КонецЦикла;
			
			
			//NOTE: выделение новых элементов визуально
			ВыделенныйЭлемент.Картинка = БиблиотекаКартинок.ФлагУстановлен;
			
			//NOTE: для любых элементов выполняется проверка на "Шаг"
			ВыделенныйЭлемент.Начало = слм_РаботаСТелевременемКлиентСерверПовтИсп.ОкруглитьВремя(
												ВыделенныйЭлемент.Начало
												,Шаг
												,ОкруглятьВверх(Шаг,ВыделенныйЭлемент.Начало));
												
			ВыделенныйЭлемент.Конец = слм_РаботаСТелевременемКлиентСерверПовтИсп.ОкруглитьВремя(
													ВыделенныйЭлемент.Конец
													,Шаг
													,ОкруглятьВверх(Шаг,ВыделенныйЭлемент.Конец));		

			ВыделенныйЭлемент.Значение = Строка(Новый УникальныйИдентификатор());			
			НовыйКэшЭлемента = КэшЭлементовПланировщика.Добавить();			
			ЗаполнитьЗначенияСвойств( НовыйКэшЭлемента, ВыделенныйЭлемент.Выгрузить() );
			НовыйКэшЭлемента.ТипПередачи = ОпределитьТипПередачи(ВыделенныйЭлемент.Текст);			
			ПроверитьНаПересечениеПоДиапазону(ВыделенныйЭлемент);		
			
		КонецЦикла;
		
	Иначе	
		
		Для каждого ВыделенныйЭлемент Из Элемент.ВыделенныеЭлементы Цикл
			
			//NOTE: проверка на пересечение
			Для каждого ЭлементПланировщика Из Планировщик.Элементы Цикл				
				Если ЭлементПланировщика.Значение <> ВыделенныйЭлемент.Значение // проверка на самого себя
					И ИнтервалыПересекаются(ВыделенныйЭлемент.Начало, ВыделенныйЭлемент.Конец, ЭлементПланировщика.Начало,ЭлементПланировщика.Конец) Тогда //есть пересечение
					ОтменаРедактирования = Истина;
				КонецЕсли;				
			КонецЦикла;		
			
			//NOTE: для любых элементов выполняется проверка на "Шаг"
			ВыделенныйЭлемент.Начало = слм_РаботаСТелевременемКлиентСерверПовтИсп.ОкруглитьВремя(
															ВыделенныйЭлемент.Начало
															,Шаг
															,ОкруглятьВверх(Шаг,ВыделенныйЭлемент.Начало));
															
			ВыделенныйЭлемент.Конец = слм_РаботаСТелевременемКлиентСерверПовтИсп.ОкруглитьВремя(
															ВыделенныйЭлемент.Конец
															,Шаг
															,ОкруглятьВверх(Шаг,ВыделенныйЭлемент.Конец));
			
			
			ПараметрыОтбора = Новый Структура("Значение", ВыделенныйЭлемент.Значение);
			НайденныеСтроки = КэшЭлементовПланировщика.НайтиСтроки(ПараметрыОтбора);
								
			Если НайденныеСтроки.Количество() = 0 Тогда
				ВызватьИсключение ТекстИсключения();				
			Иначе				
				
				НайденнаяСтрока = НайденныеСтроки[0];
				
				Если НайденнаяСтрока.Зафиксирован Тогда
					// фиксированные запрещено редактировать
					ОтменаРедактирования = Истина;
					Продолжить;
				КонецЕсли; 
				
				ЗаполнитьЗначенияСвойств(НайденнаяСтрока, ВыделенныйЭлемент.Выгрузить());				
				НайденнаяСтрока.Обновлять = Истина;
				
				Если НайденнаяСтрока.Текст <> ВыделенныйЭлемент.Текст Тогда
					
					НайденнаяСтрока.ТипПередачи = ОпределитьТипПередачи(ВыделенныйЭлемент.Текст);
					
				КонецЕсли; 
				
				ПроверитьНаПересечениеПоДиапазону(ВыделенныйЭлемент);
				
				//NOTE: обновление значений в "быстрой форме", возможно, вынести в отдельную процедуру				
				БыстроеРедактированиеНачало 	= НайденнаяСтрока.Начало;
				БыстроеРедактированиеКонец 		= НайденнаяСтрока.Конец;
				БыстроеРедактированиеЗначение 	= НайденнаяСтрока.Значение;
				БыстроеРедактированиеПодсказка 	= НайденнаяСтрока.Текст;
				НадписьШаблон = СтрШаблон("<hh:mm:ss>, %1-%2",Формат(БыстроеРедактированиеНачало,"ДФ=ЧЧ:мм:сс"),Формат(БыстроеРедактированиеКонец,"ДФ=ЧЧ:мм:сс"));
				Элементы.БыстроеРедактированиеНадпись.Заголовок	= Новый ФорматированнаяСтрока(НадписьШаблон,,WebЦвета.НейтральноСиний );
				
			КонецЕсли; //Если НайденныеСтроки.Количество() = 0 		
			
		КонецЦикла;    		
		
	КонецЕсли; //Если НовыйЭлемент
	
	Модифицированность = Истина;	
	
КонецПроцедуры

&НаКлиенте
Функция ОкруглятьВверх(Знач Шаг = 0, ДатаВремя)
	//NOTE: определение направления округления
	
	Минута = Минута(ДатаВремя);	
	Возврат ?((Минута >= Шаг/2 И Минута <= Шаг) ИЛИ (Минута >= Шаг + Шаг/2), Истина, Ложь);
	
КонецФункции //ОкруглятьВверх

// Выполняет проверку на пересечение элементов по диапазону времени
//
// Параметры:
//  ВыделенныйЭлемент	 - ЭлементПланировщика	 - 
//
&НаКлиенте
Процедура ПроверитьНаПересечениеПоДиапазону(Знач ВыделенныйЭлемент)
	
	Перем ЭлементПланировщика;
	Возврат; //TODO: пока не реализовано, отложено до выяснения требований

		
	Для каждого ЭлементПланировщика Из Планировщик.Элементы Цикл
		
		Если ЭлементПланировщика.Значение <> ВыделенныйЭлемент.Значение // проверка на самого себя
			И ИнтервалыПересекаются(ВыделенныйЭлемент.Начало, ВыделенныйЭлемент.Конец, ЭлементПланировщика.Начало,ЭлементПланировщика.Конец) Тогда //есть пересечение
	
			ВыделенныйЭлемент.ЦветФона 		= WebЦвета.НейтральноЗеленый;
			ЭлементПланировщика.ЦветФона 	= ВыделенныйЭлемент.ЦветФона;			
			КоллекцияОписанийЭлементов 	= Новый Массив;
			КоллекцияОписанийЭлементов.Добавить(ВыделенныйЭлемент.Выгрузить());
			КоллекцияОписанийЭлементов.Добавить(ЭлементПланировщика.Выгрузить());
			
			ЗафиксироватьВКэш(Истина,КэшПересечений,КэшЭлементовПланировщика,КоллекцияОписанийЭлементов);	
			
		КонецЕсли;
		
	КонецЦикла; 
	
	
	
	НепересекающиесяЭлементы = Новый Массив;
	Пересекались = Новый Соответствие;
	
	СтрокиКэша = КэшПересечений.НайтиСтроки(Новый Структура("Значение",ВыделенныйЭлемент.Значение));
	Если СтрокиКэша.Количество() > 0 Тогда
		ЗаполнитьЗначенияСвойств(СтрокиКэша[0],ВыделенныйЭлемент); 			
	КонецЕсли; 
	
	//NOTE: на входе в цикл в кэше еще есть старые элементы
	КэшПересечений.Сортировать("Начало Возр",);
	
	Для каждого ЭлементПересечения Из КэшПересечений Цикл		
		
		Пересекался = Ложь;
		                        
		Для каждого ВложенныйЭлемент Из КэшПересечений Цикл			
			
			Если ЭтоПересечениеЭлементов(ВложенныйЭлемент, ЭлементПересечения) Тогда				
				
				ПересеченныйЭлемент = Планировщик.Элементы.Найти(ВложенныйЭлемент.Значение);
				ПересеченныйЭлемент.ЦветФона = WebЦвета.НейтральноЗеленый; //цвет возвращаем на место
				
				Пересекались.Вставить(ВложенныйЭлемент.Значение,ЭлементПересечения.Значение);
				Пересекался = Истина;
				
				Продолжить;
				
			ИначеЕсли (Не ВложенныйЭлемент.Значение = ЭлементПересечения.Значение)				
				И Не ИнтервалыПересекаются(ВложенныйЭлемент.Начало,ВложенныйЭлемент.Конец,ЭлементПересечения.Начало,ЭлементПересечения.Конец)
				И Пересекались.Получить(ВложенныйЭлемент.Значение) = Неопределено Тогда
				
				НепересекающиесяЭлементы.Добавить(ВложенныйЭлемент);
				
			КонецЕсли;
			
			Если Пересекался Тогда
				Продолжить;				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	СвернутыйМассив = ОбщегоНазначенияКлиентСервер.СвернутьМассив(НепересекающиесяЭлементы);
	
	Для каждого ЭлементКоллекции Из СвернутыйМассив Цикл
		
		Планировщик.Элементы.Найти(ЭлементКоллекции.Значение).ЦветФона = WebЦвета.СветлоЖелтый;
		
		//NOTE: очистить из кэша
		ПараметрыОтбора = Новый Структура("Значение",ЭлементКоллекции.Значение);
		НайденныеСтроки = КэшПересечений.НайтиСтроки(ПараметрыОтбора);
		
		Для Индекс = 0 По НайденныеСтроки.ВГраница() Цикл			
			КэшПересечений.Удалить(НайденныеСтроки[Индекс]);			
		КонецЦикла;
		
		// последний элемент кэша очищаем принудительно
		Если КэшПересечений.Количество() = 1 Тогда 			
			Планировщик.Элементы.Найти(КэшПересечений[0].Значение).ЦветФона = WebЦвета.СветлоЖелтый;
			КэшПересечений.Очистить();			
		КонецЕсли;
		
	КонецЦикла; 
	
КонецПроцедуры

&НаКлиенте
Функция ЭтоПересечениеЭлементов(Знач ПервыйЭлемент, Знач ВторойЭлемент)
	
	Возврат (Не ПервыйЭлемент.Значение = ВторойЭлемент.Значение)				
				И ИнтервалыПересекаются(ПервыйЭлемент.Начало,
											ПервыйЭлемент.Конец,
											ВторойЭлемент.Начало,
											ВторойЭлемент.Конец);

КонецФункции

&НаКлиенте
Функция ОпределитьТипПередачи(Знач ПользовательскийТекст = "")
	
	НайденноеЗначение = Объект.Кэш.ТипыПередачи.Получить(НРег(ПользовательскийТекст));
	
	Если НайденноеЗначение = Неопределено И ЗначениеЗаполнено(ПользовательскийТекст) Тогда		
		
		НайденноеЗначение = ПолучитьТипПередачи(ПользовательскийТекст);
		Объект.Кэш.ТипыПередачи.Вставить(НРег(ПользовательскийТекст), НайденноеЗначение);
		
	КонецЕсли; 
	
	Возврат НайденноеЗначение;
	
КонецФункции

// Функция - Получить пересекаемые элементы
//
// Параметры:
//  КэшЭлементовПланировщика - ДанныеФормыКоллекция	 - 
// 
// Возвращаемое значение:
//   - 
//
&НаСервереБезКонтекста
Функция ПолучитьВсеПересекаемыеЭлементы(Знач КэшЭлементовПланировщика)
	
	ПересекаемыеЭлементы = Новый Структура("Успешно, Элементы",
													Ложь, Новый Массив);
	КолонкиПоиска 		= "Значение,Конец,Начало";													
	ТаблицаЭлементов 	= КэшЭлементовПланировщика.Выгрузить(,КолонкиПоиска);
	
	ЗапросПоиска = Новый Запрос;
	ЗапросПоиска.УстановитьПараметр("ТаблицаЭлементов",ТаблицаЭлементов);
	ЗапросПоиска.Текст = 
	"ВЫБРАТЬ
	|	ВТ_ТаблицаЭлементов.Значение,
	|	ВТ_ТаблицаЭлементов.Начало,
	|	ВТ_ТаблицаЭлементов.Конец
	|ПОМЕСТИТЬ ВТЭлементы
	|ИЗ
	|	&ТаблицаЭлементов КАК ВТ_ТаблицаЭлементов
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ПравоеКрыло.Значение,
	|	ПравоеКрыло.Начало,
	|	ПравоеКрыло.Конец
	|ИЗ
	|	ВТЭлементы КАК ПравоеКрыло
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТЭлементы КАК ЛевоеКрыло
	|		ПО ПравоеКрыло.Начало <= ЛевоеКрыло.Конец
	|			И ПравоеКрыло.Конец >= ЛевоеКрыло.Начало
	|			И ПравоеКрыло.Значение <> ЛевоеКрыло.Значение
	|
	|СГРУППИРОВАТЬ ПО
	|	ПравоеКрыло.Начало,
	|	ПравоеКрыло.Значение,
	|	ПравоеКрыло.Конец";
	
	Результат = ЗапросПоиска.Выполнить();
	
	Если Не Результат.Пустой() Тогда
		
		ПересекаемыеЭлементы.Успешно = Истина;
		
		ВыборкаПересекающихсяЭлементов = Результат.Выбрать();
		
		Пока ВыборкаПересекающихсяЭлементов.Следующий() Цикл			
			
			ОписаниеПересекаемогоЭлемента = Новый Структура(КолонкиПоиска);
			ЗаполнитьЗначенияСвойств(ОписаниеПересекаемогоЭлемента, ВыборкаПересекающихсяЭлементов);
			ПересекаемыеЭлементы.Элементы.Добавить(ОписаниеПересекаемогоЭлемента);
			
		КонецЦикла;
		
	КонецЕсли; 
	
	Возврат Новый ФиксированнаяСтруктура(ПересекаемыеЭлементы);
	
КонецФункции

#КонецОбласти

#Область ПараметрыПланировщика

// Инициализирует объект планировщик
//
&НаСервере
Процедура ИнициализироватьПланировщик()
	
	Планировщик.Элементы.Очистить();	
	Планировщик.ТекущиеПериодыОтображения.Очистить();
		
	Планировщик.ТекущиеПериодыОтображения.Добавить(Интервал.ДатаНачала, Интервал.ДатаОкончания);	
	
	ЗаполнитьЗначенияСвойств(Планировщик,НовыйОписаниеПериодичностиПланировщикаПоУмолчанию());
	
	ОписаниеСвойствПланировщика = НовыйОписаниеСвойствПланировщикаПоУмолчанию();
	
	ЗаполнитьЗначенияСвойств(Планировщик,ОписаниеСвойствПланировщика);
	
	УсловноеОформлениеОсновнойШкалыВремени();
	
	Если Планировщик.ШкалаВремени.Элементы.Количество() < ОписаниеСвойствПланировщика.КоличествоШкалВремени Тогда
		
		ПочасоваяШкала 				= Планировщик.ШкалаВремени.Элементы.Добавить();
		ПочасоваяШкала.ЦветФона 	= WebЦвета.СинийСПороховымОттенком;		
		
		ПочасоваяШкала.ЦветЛиний 	= WebЦвета.ГолубойСоСтальнымОттенком;
		ПочасоваяШкала.ЛинииДелений = Новый Линия(ТипЛинииРисункаТабличногоДокумента.Точечная,1);
		
		ПочасоваяШкала.Формат 		= "ДФ=mm:ss";
		ПочасоваяШкала.Единица 		= ТипЕдиницыШкалыВремени.Минута;
		ПочасоваяШкала.Кратность 	= 30; 		
		
	КонецЕсли; 
	
	//NOTE: раскрасить выходные	
	ИнтервалыВыходных = Новый Соответствие;	
	ДатаНачала = Интервал.ДатаНачала;	
	ПредыдущаяДата = Дата(1,1,1);           
	
	Пока ДатаНачала < Интервал.ДатаОкончания Цикл
		
		Если ДеньНедели(ДатаНачала) > 5 Тогда			
			// определим что это "соседи"
			Если НачалоДня(ДатаНачала) - НачалоДня(ПредыдущаяДата) = 60*60*24 Тогда
				ИнтервалыВыходных[ПредыдущаяДата].Конец = КонецДня(ДатаНачала);				
			Иначе								
				ИнтервалыВыходных.Вставить(ДатаНачала, Новый Структура("Начало, Конец",ДатаНачала, ДатаНачала));				
			КонецЕсли; 			
			ПредыдущаяДата = ДатаНачала;			
		КонецЕсли;		
		ДатаНачала = ДатаНачала + 60*60*24;				
	КонецЦикла; 
	
	Планировщик.ИнтервалыФона.Очистить();
	
	Для каждого ЭлементКоллекции Из ИнтервалыВыходных Цикл
		
		ИнтервалФона = Планировщик.ИнтервалыФона.Добавить(ЭлементКоллекции.Значение.Начало, ЭлементКоллекции.Значение.Конец);
		ИнтервалФона.Цвет =  Новый Цвет(254, 245, 238);
		
	КонецЦикла;
	//NOTE: раскрасить выходные
	
КонецПроцедуры

// Конструктор фиксированной структуры, описывающей периодичность планировщика по умолчанию
// 
// Возвращаемое значение:
//  ФиксированнаяСтруктура - 
//
&НаКлиентеНаСервереБезКонтекста
Функция НовыйОписаниеПериодичностиПланировщикаПоУмолчанию()
	
	ОписаниеПериодичностиПланировщика = Новый Структура;
	ОписаниеПериодичностиПланировщика.Вставить("ЕдиницаПериодическогоВарианта", ТипЕдиницыШкалыВремени.Час);
	ОписаниеПериодичностиПланировщика.Вставить("КратностьПериодическогоВарианта", 24);
	
	Возврат Новый ФиксированнаяСтруктура(ОписаниеПериодичностиПланировщика);
	
КонецФункции

// Конструктор фиксированной структуры, описающий свойства планировщика по умолчанию
// 
// Возвращаемое значение:
//  ФиксированнаяСтруктура - 
//
&НаСервереБезКонтекста
Функция НовыйОписаниеСвойствПланировщикаПоУмолчанию()
	
	ОписаниеСвойствПланировщика = Новый Структура;
	
	ОписаниеСвойствПланировщика.Вставить("ВыравниватьГраницыЭлементовПоШкалеВремени", 	Ложь);  
	ОписаниеСвойствПланировщика.Вставить("ФиксироватьЗаголовокШкалыВремени", 			Истина);
	
	ОписаниеСвойствПланировщика.Вставить("АвтоМинимальнаяВысотаСтроки", 				Ложь); // не фиксировать высоту строки
	ОписаниеСвойствПланировщика.Вставить("АвтоМинимальнаяШиринаКолонки", 				Ложь);
	
	//NOTE: временно уберу телесмещение
	//ОписаниеСвойствПланировщика.Вставить("ОтступСКонцаПереносаШкалыВремени",			слм_РаботаСТелевременемКлиентСерверПовтИсп.Телесмещение());
	//ОписаниеСвойствПланировщика.Вставить("ОтступСНачалаПереносаШкалыВремени",			слм_РаботаСТелевременемКлиентСерверПовтИсп.Телесмещение());
	
	ОписаниеСвойствПланировщика.Вставить("ПоведениеЭлементовПриНедостаткеМеста",		ПоведениеЭлементовПланировщикаПриНедостаткеМеста.ОтображатьВсеЭлементы);
	ОписаниеСвойствПланировщика.Вставить("ЦветТекста", 									ЦветаСтиля.ЦветТекстаФормы);
	ОписаниеСвойствПланировщика.Вставить("ФорматПеренесенныхЗаголовковШкалыВремени",	"ДФ='ддд, д.ММ.гг'");
	ОписаниеСвойствПланировщика.Вставить("ОтображениеВремениЭлементов", 				ОтображениеВремениЭлементовПланировщика.ВремяНачалаИКонца);	
	
	ОписаниеСвойствПланировщика.Вставить("КоличествоШкалВремени", 						2); // часы и минуты
	
	Возврат Новый ФиксированнаяСтруктура(ОписаниеСвойствПланировщика);
	
КонецФункции
 
&НаСервере
Процедура УсловноеОформлениеОсновнойШкалыВремени()
	
	ОсновнаяШкалаВремени 				= Планировщик.ШкалаВремени.Элементы[0];
	ОсновнаяШкалаВремени.ЦветФона 		= WebЦвета.СинийСоСтальнымОттенком;
	ОсновнаяШкалаВремени.ЦветТекста 	= WebЦвета.Белый;
	
	ОсновнаяШкалаВремени.ЛинииДелений 	= Новый Линия(ТипЛинииРисункаТабличногоДокумента.Сплошная,2);
	ОсновнаяШкалаВремени.ЦветЛиний 		= WebЦвета.НейтральноСерый;
	
КонецПроцедуры

// Конструктор структуры,описающий пересеченные элементы
// 
// Возвращаемое значение:
//  Структура - 
//
&НаКлиентеНаСервереБезКонтекста
Функция НовоеОписаниеПересеченныхЭлементов()
	
	ВызватьИсключение ТекстИсключения();
 	
	ОписаниеПересеченныхЭлементов = Новый Структура;
	ОписаниеПересеченныхЭлементов.Вставить("Идентификатор", Строка(Новый УникальныйИдентификатор));
	ОписаниеПересеченныхЭлементов.Вставить("Элементы", 		Новый Массив);
	
	Возврат ОписаниеПересеченныхЭлементов;
	
КонецФункции //НовыйОписаниеПересеченныхЭлементов

#КонецОбласти

#Область ОбработчикиКомандФормы

&НаКлиенте
Процедура СохранитьСетку(Команда)
	
	//TODO: при сохранении перерисовать сетку
	СохранитьЭлементыСеткиНаСервере();
	
	//TODO:обновление элементов на форме
	Перечитать(Неопределено);
	
	Модифицированность = Ложь;
	
КонецПроцедуры

&НаКлиенте
Процедура Перечитать(Команда)
	
	Планировщик.Элементы.Очистить();	
	Планировщик.ТекущиеПериодыОтображения.Очистить();
		
	Планировщик.ТекущиеПериодыОтображения.Добавить(Интервал.ДатаНачала, Интервал.ДатаОкончания);
	ЗаполнитьДаннымиВариантаСетки();
	
	Модифицированность = Ложь;
	
КонецПроцедуры

&НаКлиенте
Процедура Скрыть(Команда)
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(Элементы,Элементы.ГруппаРедактированиеЭлемента.Имя,"Видимость",Ложь);
	
КонецПроцедуры

&НаКлиенте
Процедура ПодсветитьЭлемент(Команда)
	
	ЭлементПланировщика = Планировщик.Элементы.Найти(БыстроеРедактированиеЗначение);
	ПредыдущийЦветФона 	= ЭлементПланировщика.ЦветФона; 
	ЭлементПланировщика.ЦветФона = ОбщегоНазначенияКлиентПовтИсп.ЦветСтиля("ФонУправляющегоПоля");	
	ПодключитьОбработчикОжидания("ПодсветитьЭлементОтложенно",0.5,Истина);
	
КонецПроцедуры

&НаКлиенте
Процедура ПодсветитьЭлементОтложенно()
	
	Планировщик.Элементы.Найти(БыстроеРедактированиеЗначение).ЦветФона = ПредыдущийЦветФона;
	
КонецПроцедуры

&НаКлиенте
Процедура БыстроеРедактированиеПрименить(Команда)
	
	ПараметрыОтбора = Новый Структура("Значение",БыстроеРедактированиеЗначение);
	НайденныеСтроки = КэшЭлементовПланировщика.НайтиСтроки(ПараметрыОтбора);
	
	Если НайденныеСтроки.Количество() > 0 Тогда		
		Для каждого НайденнаяСтрока Из НайденныеСтроки Цикл
			
			НайденнаяСтрока.Начало 		= БыстроеРедактированиеНачало;
			НайденнаяСтрока.Конец 		= БыстроеРедактированиеКонец;
			НайденнаяСтрока.Значение 	= БыстроеРедактированиеЗначение;
			НайденнаяСтрока.Текст    	= БыстроеРедактированиеПодсказка;
			НайденнаяСтрока.ТипПередачи = БыстроеРедактированиеТипПередачи;
			НайденнаяСтрока.Обновлять	= Истина;
			
			ЗаполнитьЗначенияСвойств(Планировщик.Элементы.Найти(БыстроеРедактированиеЗначение), НайденнаяСтрока);
			
		КонецЦикла; 		
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура Зафиксировать(Команда)
	
	Для каждого Элемент Из Элементы.Планировщик.ВыделенныеЭлементы Цикл
		
		ЗакрепитьОткрепитьЭлемент(Элемент, Истина);
		
	КонецЦикла; 	
	
КонецПроцедуры

&НаКлиенте
Процедура Открепить(Команда)
	
	Для каждого Элемент Из Элементы.Планировщик.ВыделенныеЭлементы Цикл
		
		ЗакрепитьОткрепитьЭлемент(Элемент, Ложь);
		
	КонецЦикла; 
	
КонецПроцедуры

&НаКлиенте
Процедура ЗакрепитьОткрепитьЭлемент(ЭлементПланировщика, Зафиксирован = Ложь)
	
	ПараметрыОтбора = Новый Структура("Значение", ЭлементПланировщика.Значение);
	НайденныеЭлементы = КэшЭлементовПланировщика.НайтиСтроки(ПараметрыОтбора);
	
	Если НайденныеЭлементы.Количество() = 0 Тогда			
		ВызватьИсключение ТекстИсключения();			
	Иначе
		
		ЗаполнитьЗначенияСвойств(НайденныеЭлементы[0], ЭлементПланировщика.Выгрузить());
		НайденныеЭлементы[0].Зафиксирован = Зафиксирован;
		НайденныеЭлементы[0].Обновлять = Истина;
		
		Если Зафиксирован Тогда
			ЭлементПланировщика.Картинка = БиблиотекаКартинок.Защита;
		Иначе
			ЭлементПланировщика.Картинка = Новый Картинка;
		КонецЕсли; 	
		
	КонецЕсли;	
	
КонецПроцедуры

#КонецОбласти

#Область РаботаСКэшем

// Фиксирует 
//
// Параметры:
//  ЕстьПересечения				 - Булево			 - 
//  КэшПересечений				 - ДанныеФормыКоллекция	 - 
//  КэшЭлементовПланировщика	 - ДанныеФормыКоллекция	 - 
//  КоллекцияОписанийЭлементов	 - Массив				 - 
//
&НаКлиентеНаСервереБезКонтекста
Процедура ЗафиксироватьВКэш(ЕстьПересечения = Истина, КэшПересечений, КэшЭлементовПланировщика, КоллекцияОписанийЭлементов)
	
	Если ЕстьПересечения Тогда
		
		//КэшПересечений и КэшЭлементовПланировщика
		Для каждого ОписаниеЭлемента Из КоллекцияОписанийЭлементов Цикл
			
			ПараметрыОтбора 	= Новый Структура("Значение",ОписаниеЭлемента.Значение);
			СтрокиЗначений 		= КэшПересечений.НайтиСтроки(ПараметрыОтбора);
			НайденныеСтрокиКэша = КэшЭлементовПланировщика.НайтиСтроки(ПараметрыОтбора);
			
			Если СтрокиЗначений.Количество() = 0 Тогда				
				ЗаполнитьЗначенияСвойств(КэшПересечений.Добавить(), ОписаниеЭлемента);				
			Иначе				
				ЗаполнитьЗначенияСвойств(СтрокиЗначений[0], ОписаниеЭлемента);				
			КонецЕсли;
			
			Если НайденныеСтрокиКэша.Количество() = 0 Тогда				
				ЗаполнитьЗначенияСвойств(КэшЭлементовПланировщика.Добавить(), ОписаниеЭлемента);				
			Иначе				
				ЗаполнитьЗначенияСвойств(НайденныеСтрокиКэша[0], ОписаниеЭлемента);				
			КонецЕсли; 			
			
		КонецЦикла;
		
	Иначе
		
		//КэшЭлементовПланировщика	
		Для каждого ОписаниеЭлемента Из КоллекцияОписанийЭлементов Цикл
			
			ПараметрыОтбора 	= Новый Структура("Значение",ОписаниеЭлемента.Значение);
			НайденныеСтрокиКэша = КэшЭлементовПланировщика.НайтиСтроки(ПараметрыОтбора);
			
			Если НайденныеСтрокиКэша.Количество() = 0 Тогда				
				ЗаполнитьЗначенияСвойств(КэшЭлементовПланировщика.Добавить(), ОписаниеЭлемента);				
			Иначе				
				ЗаполнитьЗначенияСвойств(НайденныеСтрокиКэша[0], ОписаниеЭлемента);				
			КонецЕсли;
			
		КонецЦикла;	
		
	КонецЕсли;
	
КонецПроцедуры

// Конструктор структуры, инициализирующей КэшированныеЗначения
// 
// Возвращаемое значение:
//  Структура - КэшТиповПередачи
//
&НаСервереБезКонтекста
Функция ИнициализироватьКэш()
	
	Кэш = Новый Структура;
	Кэш.Вставить("ТипыПередачи", Новый Соответствие);
	Кэш.Вставить("ПересекаемыеЭлементы", Неопределено);
	     
	Возврат Кэш;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьТипПередачи(Знач ВыражениеПоиска="")
	
	МенеджерТиповПередач 	= Справочники.слм_ТипыПередач;		
	ТаблицаВыраженийПоиска 	= МенеджерТиповПередач.ПолучитьТаблицаВыраженийПоиска();	
	Возврат МенеджерТиповПередач.ПолучитьТипДляПередачи(ВыражениеПоиска, ТаблицаВыраженийПоиска);
	
КонецФункции

&НаКлиенте
Процедура ОбновитьЭлементНаСервере(Знач Значение)
	
	Реквизиты = СтруктураРеквизитовНаСервере(Значение,
					"ВариантСетки,Описание,ВремяНачала,ВремяОкончания,Зафиксирован,ТипПередачи");
	
	ПараметрыОтбора = Новый Структура("Значение",Значение);
	НайденныеСтроки = КэшЭлементовПланировщика.НайтиСтроки(ПараметрыОтбора);
	
	Если НайденныеСтроки.Количество() > 0 Тогда
		
		Для каждого НайденнаяСтрока Из НайденныеСтроки Цикл
			
			ЗаполнитьЗначенияСвойств(НайденнаяСтрока,Реквизиты);
			НайденнаяСтрока.Начало 	= Реквизиты.ВремяНачала;
			НайденнаяСтрока.Конец 	= Реквизиты.ВремяОкончания;
			НайденнаяСтрока.Текст	= Реквизиты.Описание;
			НайденнаяСтрока.Обновлять = Истина;
			
			ЗаполнитьЗначенияСвойств(Планировщик.Элементы.Найти(НайденнаяСтрока.Значение),НайденнаяСтрока);
			
		КонецЦикла;	
		
	Иначе   
		
		// по идее, входа сюда быть не должно
		НоваяСтрока = НайденныеСтроки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Реквизиты);
				
	КонецЕсли;	
	
КонецПроцедуры

&НаКлиенте
Процедура ОбновитьЗаписьКэша(Знач СтрокаКэшаПересечений)
	
	Перем КэшированныеСтроки, КэшСтроки, ПересеченныйЭлемент;
	
	ПересеченныйЭлемент = Планировщик.Элементы.Найти(СтрокаКэшаПересечений.Значение);
	ПересеченныйЭлемент.ЦветФона = WebЦвета.НейтральноЗеленый; //цвет возвращаем на место
	
	КэшированныеСтроки = КэшЭлементовПланировщика.НайтиСтроки(Новый Структура("Значение",СтрокаКэшаПересечений.Значение));
	Для каждого КэшСтроки Из КэшированныеСтроки Цикл
		ЗаполнитьЗначенияСвойств(КэшСтроки, ПересеченныйЭлемент.Выгрузить());					
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает структуру реквизитов по ссылке
//
// Параметры:
//  Ссылка			 - Произвольный	 - 
//  РеквизитыСтрокой - Строка - 
// 
// Возвращаемое значение:
//   - 
//
&НаСервереБезКонтекста
Функция СтруктураРеквизитовНаСервере(Знач Ссылка, Знач РеквизитыСтрокой)
	
	Возврат ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, РеквизитыСтрокой);
	
КонецФункции //СтруктураРеквизитов

&НаСервере
Процедура ЗаполнитьДаннымиВариантаСетки()
	
	ОписаниеТаймСлотов = Справочники.слм_ВариантыСеток.ПолучитьТаймСлоты(Объект.ВариантСетки, Интервал);	
	КэшЭлементовПланировщика.Очистить();
	КэшПересечений.Очистить();
	
	Если ОписаниеТаймСлотов.Успешно Тогда		
		
		Для каждого ОписаниеТаймслота Из ОписаниеТаймСлотов.Описание Цикл			
			СоздатьЭлементПланировщика(ОписаниеТаймслота);			
		КонецЦикла;		
		
	КонецЕсли; 	
	
	ВыделитьПересекаемыеЭлементыНаСервере();
	
КонецПроцедуры

// Создает элемент планировщика
//
// Параметры:
//  ОписаниеТаймслота	 - Структура - структура таймслота с ключами, где:
//  * Ссылка  -
//  * Текст - Строка -
//  * ВремяНачала - ДатаВремя -
//  * ВремяОкончания - ДатаВремя -
//  * ТипПередачи - СправочникСсылка.слм_ТипыПередач -
//  * Зафиксирован - Булево -
//
&НаСервере
Процедура СоздатьЭлементПланировщика(Знач ОписаниеТаймслота)
	
	Перем ЭлементПланировщика;
	
	ЭлементПланировщика = Планировщик.Элементы.Добавить(ОписаниеТаймслота.ВремяНачала, ОписаниеТаймслота.ВремяОкончания);
	
	ЭлементПланировщика.Значение 	= ОписаниеТаймслота.Ссылка;
		
	ЭлементПланировщика.Шрифт 		= Новый Шрифт("Calibri",8);
	ЭлементПланировщика.ЦветТекста 	= WebЦвета.СинеСерый;
	ЭлементПланировщика.ЦветРамки 	= WebЦвета.Томатный;
	ЭлементПланировщика.ЦветФона 	= WebЦвета.СветлоСерый;
	
	КэшЭлементПланировщика = КэшЭлементовПланировщика.Добавить();                 	
	ЗаполнитьЗначенияСвойств(КэшЭлементПланировщика, ОписаниеТаймслота);
	ЗаполнитьЗначенияСвойств(КэшЭлементПланировщика, ЭлементПланировщика.Выгрузить());

КонецПроцедуры

&НаСервере
Процедура СохранитьЭлементыСеткиНаСервере()
	
	Для каждого СтрокаКэша Из КэшЭлементовПланировщика Цикл
		
		Если СтрокаКэша.Удаленный Тогда			
			УдалитьЭкземпляр(СтрокаКэша);			
		Иначе			
			создатьОбновитьЭкземплярТаймСлота(СтрокаКэша);			
		КонецЕсли; 
		
	КонецЦикла; 
	
КонецПроцедуры

&НаСервере
Процедура создатьОбновитьЭкземплярТаймСлота(Знач СтруктураЭлементаПланировщика)
	
	МенеджерСлотов = Документы.слм_ТаймСлот;
	
	Если ТипЗнч(СтруктураЭлементаПланировщика.Значение) = Тип("Строка") Тогда // новый элемент		
		
		МенеджерСлотов.Сгенерировать(
				ЭлементКоллекцииВСтруктуру(СтруктураЭлементаПланировщика), Объект.ВариантСетки);
		
	ИначеЕсли СтруктураЭлементаПланировщика.Обновлять Тогда // существующий 
		
		МенеджерСлотов.Обновить(
				ЭлементКоллекцииВСтруктуру(СтруктураЭлементаПланировщика));		
		
	КонецЕсли;	
	
КонецПроцедуры

&НаСервере
Процедура УдалитьЭкземпляр(Знач СтруктураЭлементаПланировщика)
	
	Документы.слм_ТаймСлот.Удалить(ЭлементКоллекцииВСтруктуру(СтруктураЭлементаПланировщика));
	
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция ЭлементКоллекцииВСтруктуру(Знач ДанныеФормыЭлементКоллекции)
	
	СериализуемыеСвойства = СтрРазделить("Значение,Начало,Конец,ТипПередачи,Текст,Удаленный,Зафиксирован",",",Ложь);
	
	ОписаниеЭлемента = Новый Структура;
	
	Для Индекс = 0 По СериализуемыеСвойства.ВГраница() Цикл
		ОписаниеЭлемента.Вставить(СериализуемыеСвойства[Индекс], ДанныеФормыЭлементКоллекции[СериализуемыеСвойства[Индекс]]);		
	КонецЦикла; 
	
	Возврат ОписаниеЭлемента;
	
КонецФункции //ДанныеФормыЭлементКоллекцииВСтруктуру

&НаКлиентеНаСервереБезКонтекста
Функция НеРеализовано()
	Возврат нСтр("ru = 'Функционал не реализован. Обратитесь к разработчику'");	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ТекстИсключения()
	Возврат нСтр("ru = 'Неожиданное поведение системы. Обратитесь к разработчику.'"); 	
КонецФункции

&НаСервере
Процедура ВыделитьПересекаемыеЭлементыНаСервере()
	
	Перем Идентификатор, КоллекцияОписанийЭлементов, ОписаниеПересечений, ЭлементКоллекции, ЭлементПланировщика;
	
	ОписаниеПересечений = ПолучитьВсеПересекаемыеЭлементы(КэшЭлементовПланировщика);
	
	Если ОписаниеПересечений.Успешно Тогда
		
		КоллекцияОписанийЭлементов 	= Новый Массив;
		
		Для каждого ЭлементКоллекции Из ОписаниеПересечений.Элементы Цикл
			
			ЭлементПланировщика 			= Планировщик.Элементы.Найти(ЭлементКоллекции.Значение);
			ЭлементПланировщика.ЦветФона 	= WebЦвета.НейтральноЗеленый;
			
			КоллекцияОписанийЭлементов.Добавить(ЭлементПланировщика.Выгрузить());
			
		КонецЦикла; 
		
		ЗафиксироватьВКэш(Истина, КэшПересечений, КэшЭлементовПланировщика, КоллекцияОписанийЭлементов);
		
	КонецЕсли;

КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция ИнтервалыПересекаются(Начало1, Конец1, Начало2, Конец2)
	Возврат ((Начало1 >= Начало2) И (Начало1 < Конец2)) ИЛИ ((Начало2 >= Начало1) И (Начало2 < Конец1));
КонецФункции // ИнтервалыПерескаются() 

&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьВремяСУчетомШага(МинутВПериоде = 30, Знач ДатаВремя)

	Возврат слм_РаботаСТелевременемКлиентСерверПовтИсп.ОкруглитьВремя(ДатаВремя, МинутВПериоде, Истина);
	
КонецФункции

// Конструктор Соответствие, описывающей шаги слота для округления времени
// 
// Возвращаемое значение:
//  ФиксированнаяСтруктура - 
//
&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеШаговСлота()
	
	НовыйОписаниеШаговСлота = Новый Соответствие;
	НовыйОписаниеШаговСлота.Вставить(НРег("Полчаса"), 		30);
	НовыйОписаниеШаговСлота.Вставить(НРег("час"), 			60);
	НовыйОписаниеШаговСлота.Вставить(НРег("Произвольный"), 	1);
	
	Возврат Новый ФиксированноеСоответствие(НовыйОписаниеШаговСлота);
	
КонецФункции 

#КонецОбласти